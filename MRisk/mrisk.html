<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"> 
	<title>MRisk - A Modified Risk Game</title>
</head>
<body style="margin: 0; text-align: center;" oncontextmenu="return false">

	<canvas id="canvas"></canvas>

</body>

<script type="text/javascript"> 
	// These are some utility functions to make life easier
	// The game doesn't depend upon them

	clog = console.log;

    // Usefule Type Checking Function

	// assert(door, NotEmpty); or assert(NotEmpty, door);
	//		Fails for null, '', undefined
	//		Success for any non empty object
	// assert(door instanceof Door, true);
	//		Checks for objects that were made using new keyword
	// assert(typeof name, 'string')
	//		Checks of type of built in objects
	// assert(typeof foo, 'function')
	// 		Also works

    assert = function(obj1, obj2, msg) {
    	if(obj1 === NotEmpty && !obj2)
    		throw Error(msg);
    	if(obj2 === NotEmpty && !obj1)
    		throw Error(msg);
    	if(obj1 !== obj2 && obj1 !== NotEmpty && obj2 != NotEmpty) 
    		throw Error(msg);
    }

    // A special long unique string to ensure non empty objects using assrt()
    NotEmpty = 'ODH@<)UD@D(@#>DJIJEIDKLADJ<@UD(UD>KLDM:LEDJ';

    // Define constant object members

    final = (obj, key, value) => {
    	assert(obj, NotEmpty, 'Object cannot be empty');
    	assert(key, NotEmpty, 'Key cannot be empty');
		Object.defineProperty( obj, key, {
			value: value,
			writable: false,
			enumerable: true,
			configurable: true
		}); // Makes obj.<key> unwritable and final
    }

</script>

<script type="text/javascript">
	class Zone {
		constructor(name, x, y, neighbours){
			assert(name, NotEmpty, 'Name of Zone cannot be empty');
			assert(typeof name, 'string', 'Name of Zone should be a String');
			assert(neighbours.constructor.name, 'Array', 'Neihbous should be array');
			assert(typeof x === 'number' && !isNaN(x), true, 'X should be a valid number');
			assert(typeof y === 'number' && !isNaN(y), true, 'Y should be a valid number');
			neighbours.forEach(s => { assert(typeof s, 'string', 'Neighbours should be names'); })
			final(this, 'name', name);
			final(this, 'neighbours', neighbours);
			final(this, 'x', x);
			final(this, 'y', y);
			this.Infantry = 1;
			this.Cavalry = 0;
			this.Artillery = 0;
			this.master = null;
			this.highlighted = false;
		}

		isNeighbour(name) { return this.neighbours.find(s => s === name) !== undefined; }
		draw(ctx, w, h) {
			let style = "#fff";
			if(this.master !== null){
				style = this.master.color;
			}
			if(this.highlighted) ctx.fillStyle = style + "6";
			else ctx.fillStyle = style + "3";
			ctx.fillRect(this.x, this.y, w, h);
		}
		drawNames(ctx, w, h, fs) { 
			ctx.fillText(this.name, this.x, this.y + h/2); 
			ctx.fillText(`${this.Infantry} - ${this.Cavalry} - ${this.Artillery}`, this.x, this.y + h/2 + fs); 	
		}	
	}

	class GameMap {
		constructor(zones){
			assert(zones.constructor.name, 'Array', 'Zones has to be an array of Zones');
			zones.forEach(s => { assert(s.constructor.name, "Zone", 'Every zone is a zone'); });
			if(zones.length < 2) throw Error("Lol Map this is");
			final(this, 'zones', zones);

			// Verify that the adjecency lists are symmetric
			zones.forEach(s => { 
				s.neighbours.forEach(t => {
					let tzone = zones.find(z => z.name === t);
					assert(tzone.isNeighbour(s.name), true, t + ' should be a neighbour of ' + s.name);
				});
			});
		}

		getZone (name) { return this.zones.find(s => s.name === name); }
		areNeighbours(name1, name2) { return this.getZone(name1).isNeighbour(name2); }
		getZoneAt(x, y) {
			for(let z of this.zones) {
				if(z.x < x && z.x + w > x){
					if(z.y < y && z.y + h > y) return z;
				}
			}
		}

		draw(ctx, width, height){
			this.zones.forEach(s => { s.draw(ctx, w, h); });
			ctx.fillStyle = "#fff";
			this.zones.forEach(s => { s.drawNames(ctx, w, h, fontSize); });
		}

		randomlyAlotPlayers() {
			let rem = ZONES
				.filter(s => s.master === null)
				.sort(s => 0.5 < Math.random()); // Filter and shulffle
			let idx = 0;
			for(let z of rem) {
				z.master = PLAYERS[idx++];
				if(idx === PLAYERS.length) idx = 0;
			}

			ZONES.forEach(z => { z.master.numZonesOwned++; } );
		}

		highlight(pred, state) {
			this.zones.filter(pred).forEach(z => z.highlighted = state);
		}
		
	}

	class Player {
		constructor(color, numPlayers){
			assert(color, NotEmpty, 'Color Cannot be Empty');
			assert(color.charAt(0), '#', 'Color must be a hex code');
			final(this, 'color', color);
			final(this, 'zones', []);
			this.capital = null;
			if(numPlayers === 2)
				this.capital2 = null;
			this.gold = 24;
			this.numZonesOwned = 0;
		}

		choseCapital(callback) {
			assert(typeof callback, 'function', 'Callback should be function.');
			if(this.capital && this.capital2) return;
			let choices = MAP.zones
				.filter(s => s.master === null)
				.sort(s => 0.5 < Math.random())
				.slice(0, 10);
			choices.forEach(s => { s.highlighted = true; });
			let self = this;
			let f = (z => {
				if(choices.includes(z)){
					if(!this.capital) this.capital = z;
					else if(!this.capital2) this.capital2 = z;
					z.master = self;
					MAP.highlight(z => true, false);
					callback();
				}
				else pickZone(f);
			});
			pickZone(f);
		}

		draw(ctx) {
			if(this.capital){
				ctx.fillStyle = this.color;
				ctx.fillRect(this.capital.x, this.capital.y, w, h/10);
 			}
			if(this.capital2){
				ctx.fillStyle = this.color;
				ctx.fillRect(this.capital2.x, this.capital2.y, w, h/10);
 			}
		}

		drawHUD(ctx) {
			ctx.fillStyle = this.color + "4";
			ctx.fillRect(width * 0.8, 0, 0.2*width, height);
			ctx.fillStyle = "#fff";
			ctx.fillText("Gold: " + this.gold, width * 0.825, height * 0.1);
			if(this.capital)
				ctx.fillText("Capital: " + this.capital.name, width * 0.825, height * 0.15);
			if(this.capital2)
				ctx.fillText("Capital 2: " + this.capital2.name, width * 0.825, height * 0.2);
			ctx.fillText("# of Zones Owned: " + this.numZonesOwned, width * 0.825, height * 0.25);
		}
	}

	class Button {
		constructor(name, x, y, w, h) {
			assert(name, NotEmpty, 'Name of a button cannot be Empty');
			assert(isNaN(x), false, 'x has to be a number');
			assert(isNaN(y), false, 'y has to be a number');
			assert(isNaN(w), false, 'w has to be a number');
			assert(isNaN(h), false, 'h has to be a number');
			final(this, 'x', Math.floor(x));
			final(this, 'y', Math.floor(y));
			final(this, 'w', Math.floor(w));
			final(this, 'h', Math.floor(h));
			final(this, 'name', name);
		}

		draw(ctx) {
			ctx.fillStyle = "#ff09";
			ctx.fillRect(this.x, this.y, this.w, this.h);
			ctx.fillStyle = "#000";
			let g = ctx.measureText(this.name);
			ctx.fillText(this.name, this.x + this.w/2 - g.width/2, this.y + this.h/2);
		}

		contains(x, y){
			if(this.x < x && this.x + this.w > x){
				return (this.y < y && this.y + this.h > y);
			}
			return false;
		}
	}

</script>

<script type="text/javascript">
	canvas = document.getElementById("canvas");
	canvas.width = Math.floor(window.innerWidth);
	canvas.height = Math.floor(window.innerHeight * 0.999);
	ctx = canvas.getContext('2d', { alpha: false });

	camera = {
		x: 350, y: 100
	}
	mouse = {
		lastPos: {x: 0, y: 0},
		rightDown: false
	}

	width = canvas.width; height = canvas.height;
	time = 0;

	zonePickCallBack = undefined;
	hudButtonCallback = undefined;

	document.addEventListener('mousemove',(e) =>{
		if(mouse.rightDown){
			camera.x += e.clientX - mouse.lastPos.x;
			camera.y += e.clientY - mouse.lastPos.y;
		}
		mouse.lastPos.x = e.clientX;
		mouse.lastPos.y = e.clientY;
	});
	document.addEventListener('mousedown', (e) => {
		if(e.button === 0 && zonePickCallBack){
			let zone = MAP.getZoneAt(e.clientX - camera.x, e.clientY - camera.y);
			let f = zonePickCallBack;
			zonePickCallBack = undefined;
			f(zone);
		}
		if(e.button === 0 && hudButtonCallback){
			let btn = HUD.getButtonAt(e.clientX, e.clientY);
			let f = hudButtonCallback;
			hudButtonCallback = undefined;
			f(btn);
		}
		if(e.button === 2) mouse.rightDown = true;
	});
	document.addEventListener('mouseup', (e) => {
		if(e.button === 2) mouse.rightDown = false;
	});

	pickZone = (callback) => {
		assert(typeof callback, 'function', 'Zone pick should be a function');
		zonePickCallBack = callback;
	}

	pressButton = (callback) => {
		assert(typeof callback, 'function', 'Press button should be a function');
		hudButtonCallback = callback;
	}

	draw = () => {
		time++;
		ctx.fillStyle = "#000";
		ctx.fillRect(0, 0, width, height);

		ctx.translate(camera.x, camera.y);
		MAP.draw(ctx, width, height);
		PLAYERS.forEach(s => s.draw(ctx));
		ctx.translate(-camera.x, -camera.y);

		curPlayer().drawHUD(ctx);
		HUD.draw(ctx);
		// ctx.strokeStyle = "#fff";
		// ctx.beginPath();
		// ctx.arc(width/2, height/2, Math.min(width, height)/4, time / 10, time /10 + 1.57);
		// ctx.stroke();
		// ctx.closePath();

		requestAnimationFrame(draw);
	}
</script>

<script type="text/javascript">

	// Draw the map on the first 80% of the screen
	let w = Math.floor(width * 0.8 / 10);
	let h = Math.floor(height / 10);
	let fontSize = Math.floor(Math.sqrt(w * h)/4.5);
	ctx.font = fontSize + "px Georgia";

	let ZONES = [
		new Zone('Paris', 		1*w, 2*h, ['London', 'Brussels', 'Stuttgart', 'Nantes', 'Geneva']),
		new Zone('London', 		0*w, 1*h, ['Paris', 'Manchester', 'Plymouth']),
		new Zone('Manchester',	-1*w, 0*h, ['London', 'Dublin']),
		new Zone('Dublin',		-2*w, 1*h, ['Manchester', 'Plymouth']),
		new Zone('Plymouth',	-1*w, 2*h, ['Dublin', 'London', 'Nantes']),
		new Zone('Berlin', 		4*w, 2*h, ['Prague', 'Hamburg', 'Warsaw', 'Frankfurt', 'Munich', 'Hague']),
		new Zone('Minsk', 		6*w, 2*h, ['Warsaw', 'Moscow', 'Kyiv', 'Riga']),
		new Zone('Moscow', 		7*w, 2*h, ['Minsk', "Kyiv", 'Riga']),
		new Zone('Riga', 		6*w, 1*h, ['Minsk', 'Moscow', 'Helsinki']),
		new Zone('Helsinki',	6*w, 0*h, ['Riga', 'Stockholm']),
		new Zone('Stockholm',	5*w, -1*h, ['Helsinki', 'Copenhagen']),
		new Zone('Vienna', 		4*w, 4*h, ['Prague', 'Warsaw', 'Budapest', 'Munich', 'Graz', 'Krakow']),
		new Zone('Krakow', 		5*w, 4*h, ['Vienna', 'Warsaw', 'Budapest', 'Prague', 'Kyiv', 'Bucharest']),
		new Zone('Budapest',	5*w, 5*h, ['Vienna', 'Krakow', 'Bucharest', 'Sarajevo', 'Isanbul', 'Athens']),
		new Zone('Sarajevo',	4*w, 6*h, ['Budapest', 'Athens']),
		new Zone('Bucharest',	6*w, 5*h, ['Budapest', 'Krakow', 'Isanbul', 'Athens']),
		new Zone('Isanbul',		6*w, 6*h, ['Bucharest', 'Budapest', 'Athens']),
		new Zone('Athens',		5*w, 6*h, ['Bucharest', 'Budapest', 'Isanbul', 'Sarajevo']),
		new Zone('Prague', 		4*w, 3*h, ['Berlin', 'Frankfurt', 'Vienna', 'Munich', 'Graz', 'Krakow', 'Warsaw']),
		new Zone('Warsaw', 		5*w, 3*h, ['Berlin', 'Vienna', 'Minsk', 'Kyiv', 'Krakow', 'Prague']),
		new Zone('Kyiv', 		6*w, 3*h, ['Warsaw', 'Moscow', 'Minsk', 'Krakow']),
		new Zone('Hamburg', 	4*w, 1*h, ['Berlin', 'Hague', 'Frankfurt', 'Copenhagen']),
		new Zone('Copenhagen', 	4*w, 0*h, ['Hamburg', 'Stockholm', 'Hague']),
		new Zone('Brussels', 	2*w, 1*h, ['Paris', 'Hague', 'Frankfurt']),
		new Zone('Stuttgart', 	2*w, 3*h, ['Paris', 'Frankfurt', 'Geneva', 'Munich', 'Graz', 'Milan']),
		new Zone('Nantes', 		0*w, 3*h, ['Paris', 'Geneva', 'Plymouth', 'Marseille', 'Barcelona']),
		new Zone('Marseille',	0*w, 4*h, ['Nantes', 'Geneva', 'Monaco', 'Barcelona']),
		new Zone('Barcelona',	-1*w, 4*h, ['Marseille', 'Nantes', 'Madrid']),
		new Zone('Madrid',		-2*w, 5*h, ['Barcelona', 'Lisbon', 'Porto']),
		new Zone('Lisbon',		-3*w, 5*h, ['Madrid', 'Porto']),
		new Zone('Porto',		-3*w, 4*h, ['Madrid', 'Lisbon']),
		new Zone('Geneva', 		1*w, 3*h, ['Paris', 'Nantes', 'Stuttgart', 'Milan', 'Marseille', 'Monaco']),
		new Zone('Monaco', 		1*w, 4*h, ['Milan', 'Marseille', 'Venice', 'Rome', 'Geneva']),
		new Zone('Venice', 		2*w, 5*h, ['Milan', 'Monaco', 'Graz', 'Rome']),
		new Zone('Rome', 		2*w, 6*h, ['Venice', 'Monaco']),
		new Zone('Hague', 		3*w, 1*h, ['Brussels', 'Hamburg', 'Frankfurt', 'Copenhagen', 'Berlin']),
		new Zone('Frankfurt', 	3*w, 2*h, ['Brussels', 'Stuttgart', 'Hamburg', 'Prague', 'Berlin', 'Hague', 'Munich']),
		new Zone('Munich', 		3*w, 3*h, ['Stuttgart', 'Frankfurt', 'Vienna', 'Prague', 'Berlin', 'Graz', 'Milan']),
		new Zone('Graz', 		3*w, 4*h, ['Stuttgart', 'Munich', 'Vienna', 'Prague', 'Milan', 'Venice']),
		new Zone('Milan', 		2*w, 4*h, ['Geneva', 'Stuttgart', 'Munich', 'Graz', 'Monaco', 'Venice']),
	]
	let MAP = new GameMap(ZONES);
	let PLAYERS = [ new Player("#f00", 2), new Player("#0f0", 2) ];
	let HUD = {
		x: 0, y: height*0.8, w: width*0.8, h: height*0.2,
		labelX: width * 0.05, labelY: height*0.975,
		buttons: [ new Button('Add', width * 0.05, height * 0.825, width*0.05, height*0.1)],
		label: '',
		draw: (ctx) => {
			ctx.fillStyle = "#ff04";
			ctx.fillRect(HUD.x, HUD.y, HUD.w, HUD.h);
			HUD.buttons.forEach(s => s.draw(ctx));
			ctx.fillText(HUD.label, HUD.labelX, HUD.labelY);
		},

		getButtonAt: (x, y) => {
			for(let i of HUD.buttons){
				if(i.contains(x, y)) return i;
			}
		},

		showAddButtons: () => {
			HUD.buttons = HUD.buttons.concat([
				new Button("Infantry", width * 0.05, height * 0.65, width*0.075, height*0.1),
				new Button("Cavalry", width * 0.15, height * 0.65, width*0.075, height*0.1),
				new Button("Artillery", width * 0.25, height * 0.65, width*0.075, height*0.1),
			]);
		},
		hideAddButtons: () => {
			HUD.buttons = HUD.buttons.filter(s => 
				s.name !== "Infantry" && s.name !== "Cavalry" && s.name !== "Artillery"
			);
		}
	}

	let COST_TROOP = {
		'Infantry': 1, 'Cavalry': 3, 'Artillery': 5
	};
	let currentPlayerIndex = 0;

	curPlayer = () => { return PLAYERS[currentPlayerIndex]; }
	changePlayer = () => { currentPlayerIndex = (currentPlayerIndex) ? 0 : 1; }

	HUD.label = 'Red Player must choose their Capital.';
	curPlayer().choseCapital(() => {
		HUD.label = 'Green Player must choose their Capital.';
		changePlayer();
		curPlayer().choseCapital(() => {
			HUD.label = 'Red Player must choose their Capital.';
			changePlayer();
			curPlayer().choseCapital(() => {
				HUD.label = 'Green Player must choose their Capital.';
				changePlayer();
				curPlayer().choseCapital(() => {
					HUD.label = 'All other zones have been randomly distributed. It is Red player\'s turn.';
					MAP.randomlyAlotPlayers();
					setTimeout(playGame, 1);
				});
			});
		});
	});

	draw();

	playGame = () => {
		// Every chance begins with Player pressing a HUD button 
		// and then selecting a zone to act upon
		let player = curPlayer();

		let btnCall = (btn) => {
			if(!btn || btn.name !== 'Add') {
				pressButton(btnCall);
				return;
			}
			HUD.showAddButtons();
			HUD.label = 'Choose Infantry, Cavalry, or Artillery. Click anywhere else to cancel.';
			pressButton((b) => {
				if(!b || (b.name !== 'Infantry' && b.name !== 'Cavalry' && b.name !== 'Artillery')) {
					HUD.hideAddButtons();
					pressButton(btnCall);
					return;
				}
				let troop = b.name;
				HUD.label = `Choose a territory to place your ${troop}.`;
				MAP.highlight(s => s.master === player, true);
				zoneCallback = (zone) => {
					if(zone && zone.master === player) {
						HUD.label = `You have chosen ${zone.name}.`;
						let num = parseInt(prompt(`Enter the number of ${troop} to add to ${zone.name}`));
						if(isNaN(num) || player.gold - num * COST_TROOP[troop] < 0){
							HUD.label = `Choose a territory to place your ${troop}.`;
							alert('Please enter a valid number.');
							pickZone(zoneCallback);
							return;
						}
						MAP.highlight(z => true, false);
						HUD.hideAddButtons();
						zone[troop] += num;
						player.gold -= num * COST_TROOP[troop];
						HUD.label = `Added ${num} ${troop} to ${zone.name}.`;
						pressButton(btnCall);
					}
					else pickZone(zoneCallback);
				}
				pickZone(zoneCallback);

			});
		};

		pressButton(btnCall);

	}
</script>
</html>