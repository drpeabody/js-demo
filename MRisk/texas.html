<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"> 
	<title>MRisk - A Modified Risk Game</title>
</head>
<body style="margin: 0; text-align: center; padding-top: 2.5%;">

	<canvas id="canvas"></canvas>

</body>

<script type="text/javascript"> 
	// These are some utility functions to make life easier
	// The game doesn't depend upon them

	// $() -> 							document
	// $(".abc") -> 					HTMLCollection with all elements that have class 'abc'
	// $(".abc", n) -> 					nth node in HTMLCollection with all 
	//									elements that have class 'abc'
	// $("#fgh") -> 					element with id "fgh"
	// $("#fgh", 'li some string') -> 	insert 'li' node with innerHTML = 'some string' 
	//									into element whose id is 'fgh'

	$ = (name, idx) => {
		if(!name || name === '') return document;
		else if(name.startsWith('.')) {
			var docs = document.getElementsByClassName(name.substring(1));
			if(isNaN(idx)) return docs;
			else return docs[idx];
		}
		else if(name.startsWith('#')) {
			if(!idx)
				return document.getElementById(name.substring(1));
			else {
				var idxFirstSpace = idx.indexOf(" ");
				var tag = idx.substring(0, idxFirstSpace);
				var args = idx.substring(idxFirstSpace + 1);
				var elem = document.createElement(tag);
				elem.innerHTML = args;
				elem.animate([ {opacity: 0}, {opacity: 100} ], {duration: 250});
				document.getElementById(name.substring(1)).appendChild(elem);
			}
		}
	}
	clog = console.log;

    // Usefule Type Checking Function

	// assert(!!door, true); 
	//		Fails for null, '', undefined
	//		Success for any non empty object
	// assert(door instanceof Door, true);
	//		Checks for objects that were made using new keyword
	// assert(typeof name, 'string')
	//		Checks of type of built in objects
	// assert(typeof foo, 'function')
	// 		Also works

    assert = function(obj1, obj2, msg) {
    	if(obj1 === NotEmpty && !obj2)
    		throw Error(msg);
    	if(obj2 === NotEmpty && !obj1)
    		throw Error(msg);
    	if(obj1 !== obj2 && obj1 !== NotEmpty && obj2 != NotEmpty) 
    		throw Error(msg);
    }

    // A special long unique string to ensure non empty objects using assrt()
    NotEmpty = 'ODH@<)UD@D(@#>DJIJEIDKLADJ<@UD(UD>KLDM:LEDJ';

    // Define constant object members

    final = (obj, key, value) => {
    	assert(obj, NotEmpty, 'Object cannot be empty');
    	assert(key, NotEmpty, 'Key cannot be empty');
		Object.defineProperty( obj, key, {
			value: value,
			writable: false,
			enumerable: true,
			configurable: true
		}); // Makes obj.<key> unwritable and final
    }

</script>

<script type="text/javascript">
	class Zone {
		constructor(name, x, y, neighbours){
			assert(name, NotEmpty, 'Name of Zone cannot be empty');
			assert(typeof name, 'string', 'Name of Zone should be a String');
			assert(neighbours.constructor.name, 'Array', 'Neihbous should be array');
			assert(typeof x === 'number' && !isNaN(x), true, 'X should be a valid number');
			assert(typeof y === 'number' && !isNaN(y), true, 'Y should be a valid number');
			neighbours.forEach(s => { assert(typeof s, 'string', 'Neighbours should be names'); })
			final(this, 'name', name);
			final(this, 'neighbours', neighbours);
			final(this, 'x', x);
			final(this, 'y', y);
		}

		isNeighbour(name) { return this.neighbours.find(s => s === name) !== undefined; }
		draw(ctx, w, h) { ctx.fillRect(this.x, this.y, w, h); }
		drawNames(ctx, w, h, fs) { 
			ctx.fillText(this.name, this.x + (w - this.name.length * fs)/5, this.y + h/2); 
		}
	}

	class GameMap {
		constructor(zones){
			assert(zones.constructor.name, 'Array', 'Zones has to be an array of Zones');
			zones.forEach(s => { assert(s.constructor.name, "Zone", 'Every zone is a zone'); });
			if(zones.length < 2) throw Error("Lol Map this is");
			final(this, 'zones', zones);

			// Verify that the adjecency lists are symmetric
			zones.forEach(s => { 
				s.neighbours.forEach(t => {
					let tzone = zones.find(z => z.name === t);
					assert(tzone.isNeighbour(s.name), true, t + ' should be a neighbour of ' + s.name);
				});
			});
		}

		getZone (name) { return this.zones.find(s => s.name === name); }
		areNeighbours(name1, name2) { return this.getZone(name1).isNeighbour(name2); }

		draw(ctx, width, height){

			ctx.font = fontSize + "px Georgia";
			ctx.fillStyle = "#333";
			this.zones.forEach(s => { s.draw(ctx, w, h); });
			ctx.fillStyle = "#fff";
			this.zones.forEach(s => { s.drawNames(ctx, w, h, fontSize); });
		}
		
	}

</script>

<script type="text/javascript">
	canvas = $("#canvas");
	canvas.width = Math.floor(window.innerWidth * 0.9);
	canvas.height = Math.floor(window.innerHeight * 0.9);
	ctx = canvas.getContext('2d');

	camera = {
		x: 0, y: 0
	}
	mouse = {
		lastPos: {x: 0, y: 0},
		leftDown: false
	}

	width = canvas.width; height = canvas.height;
	time = 0;

	document.addEventListener('mousemove',(e) =>{
		if(mouse.leftDown){
			camera.x += e.clientX - mouse.lastPos.x;
			camera.y += e.clientY - mouse.lastPos.y;
		}
		mouse.lastPos.x = e.clientX;
		mouse.lastPos.y = e.clientY;
	});
	document.addEventListener('mousedown', (e) => {
		if(e.button === 0) mouse.leftDown = true;
	});
	document.addEventListener('mouseup', (e) => {
		if(e.button === 0) mouse.leftDown = false;
	})

	draw = () => {
		ctx.translate(camera.x, camera.y);
		time++;

		ctx.fillStyle = "#000";
		ctx.fillRect(0, 0, width, height);

		MAP.draw(ctx, width, height);

		ctx.strokeStyle = "#fff";
		ctx.beginPath();
		ctx.arc(width/2, height/2, Math.min(width, height)/4, time / 10, time /10 + 1.57);
		ctx.stroke();
		ctx.closePath();


		ctx.translate(-camera.x, -camera.y);
		requestAnimationFrame(draw);
	}
</script>

<script type="text/javascript">

	// Draw the map on the first 80% of the screen
	let w = Math.floor(width * 0.8 / 10);
	let h = Math.floor(height / 10);
	let fontSize = Math.floor(Math.sqrt(w * h)/2.5);

	let ZONES = [
		new Zone('Paris', 		1*w, 2*h, ['London', 'Brussels', 'Stuttgart', 'Nantes']),
		new Zone('London', 		0*w, 1*h, ['Paris']),
		new Zone('Berlin', 		5*w, 2*h, ['Moscow', 'Amsterdam']),
		new Zone('Moscow', 		5*w, 3*h, ['Berlin']),
		new Zone('Amsterdam', 	4*w, 1*h, ['Berlin', 'Hague']),
		new Zone('Brussels', 	2*w, 1*h, ['Paris', 'Hague']),
		new Zone('Stuttgart', 	2*w, 3*h, ['Paris']),
		new Zone('Nantes', 		0*w, 3*h, ['Paris']),
		new Zone('Hague', 		3*w, 0*h, ['Brussels', 'Amsterdam']),
	]

	let MAP = new GameMap(ZONES);
	draw();
</script>
</html>